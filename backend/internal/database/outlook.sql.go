// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: outlook.sql

package database

import (
	"context"
	"database/sql"
)

const createOutlookMessage = `-- name: CreateOutlookMessage :exec
INSERT INTO outlook_messages (id, from_email, to_email, subject, body_content, body_type, is_read, received_datetime, session_id)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateOutlookMessageParams struct {
	ID               string         `json:"id"`
	FromEmail        string         `json:"from_email"`
	ToEmail          string         `json:"to_email"`
	Subject          string         `json:"subject"`
	BodyContent      sql.NullString `json:"body_content"`
	BodyType         string         `json:"body_type"`
	IsRead           int64          `json:"is_read"`
	ReceivedDatetime string         `json:"received_datetime"`
	SessionID        string         `json:"session_id"`
}

func (q *Queries) CreateOutlookMessage(ctx context.Context, arg CreateOutlookMessageParams) error {
	_, err := q.db.ExecContext(ctx, createOutlookMessage,
		arg.ID,
		arg.FromEmail,
		arg.ToEmail,
		arg.Subject,
		arg.BodyContent,
		arg.BodyType,
		arg.IsRead,
		arg.ReceivedDatetime,
		arg.SessionID,
	)
	return err
}

const deleteOutlookSessionData = `-- name: DeleteOutlookSessionData :exec
DELETE FROM outlook_messages WHERE session_id = ?
`

func (q *Queries) DeleteOutlookSessionData(ctx context.Context, sessionID string) error {
	_, err := q.db.ExecContext(ctx, deleteOutlookSessionData, sessionID)
	return err
}

const getOutlookMessageByID = `-- name: GetOutlookMessageByID :one
SELECT id, from_email, to_email, subject, body_content, body_type, is_read, received_datetime, created_at
FROM outlook_messages
WHERE id = ? AND session_id = ?
`

type GetOutlookMessageByIDParams struct {
	ID        string `json:"id"`
	SessionID string `json:"session_id"`
}

type GetOutlookMessageByIDRow struct {
	ID               string         `json:"id"`
	FromEmail        string         `json:"from_email"`
	ToEmail          string         `json:"to_email"`
	Subject          string         `json:"subject"`
	BodyContent      sql.NullString `json:"body_content"`
	BodyType         string         `json:"body_type"`
	IsRead           int64          `json:"is_read"`
	ReceivedDatetime string         `json:"received_datetime"`
	CreatedAt        int64          `json:"created_at"`
}

func (q *Queries) GetOutlookMessageByID(ctx context.Context, arg GetOutlookMessageByIDParams) (GetOutlookMessageByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getOutlookMessageByID, arg.ID, arg.SessionID)
	var i GetOutlookMessageByIDRow
	err := row.Scan(
		&i.ID,
		&i.FromEmail,
		&i.ToEmail,
		&i.Subject,
		&i.BodyContent,
		&i.BodyType,
		&i.IsRead,
		&i.ReceivedDatetime,
		&i.CreatedAt,
	)
	return i, err
}

const listOutlookMessages = `-- name: ListOutlookMessages :many
SELECT id, from_email, to_email, subject, body_content, body_type, is_read, received_datetime
FROM outlook_messages
WHERE session_id = ?
ORDER BY received_datetime DESC
LIMIT ?
`

type ListOutlookMessagesParams struct {
	SessionID string `json:"session_id"`
	Limit     int64  `json:"limit"`
}

type ListOutlookMessagesRow struct {
	ID               string         `json:"id"`
	FromEmail        string         `json:"from_email"`
	ToEmail          string         `json:"to_email"`
	Subject          string         `json:"subject"`
	BodyContent      sql.NullString `json:"body_content"`
	BodyType         string         `json:"body_type"`
	IsRead           int64          `json:"is_read"`
	ReceivedDatetime string         `json:"received_datetime"`
}

func (q *Queries) ListOutlookMessages(ctx context.Context, arg ListOutlookMessagesParams) ([]ListOutlookMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, listOutlookMessages, arg.SessionID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOutlookMessagesRow{}
	for rows.Next() {
		var i ListOutlookMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.FromEmail,
			&i.ToEmail,
			&i.Subject,
			&i.BodyContent,
			&i.BodyType,
			&i.IsRead,
			&i.ReceivedDatetime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOutlookMessagesBySession = `-- name: ListOutlookMessagesBySession :many
SELECT id, from_email, to_email, subject, body_content, body_type, is_read, received_datetime, created_at
FROM outlook_messages
WHERE session_id = ?
ORDER BY received_datetime DESC
`

type ListOutlookMessagesBySessionRow struct {
	ID               string         `json:"id"`
	FromEmail        string         `json:"from_email"`
	ToEmail          string         `json:"to_email"`
	Subject          string         `json:"subject"`
	BodyContent      sql.NullString `json:"body_content"`
	BodyType         string         `json:"body_type"`
	IsRead           int64          `json:"is_read"`
	ReceivedDatetime string         `json:"received_datetime"`
	CreatedAt        int64          `json:"created_at"`
}

// UI data queries
func (q *Queries) ListOutlookMessagesBySession(ctx context.Context, sessionID string) ([]ListOutlookMessagesBySessionRow, error) {
	rows, err := q.db.QueryContext(ctx, listOutlookMessagesBySession, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOutlookMessagesBySessionRow{}
	for rows.Next() {
		var i ListOutlookMessagesBySessionRow
		if err := rows.Scan(
			&i.ID,
			&i.FromEmail,
			&i.ToEmail,
			&i.Subject,
			&i.BodyContent,
			&i.BodyType,
			&i.IsRead,
			&i.ReceivedDatetime,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOutlookMessages = `-- name: SearchOutlookMessages :many
SELECT id, from_email, to_email, subject, body_content, body_type, is_read, received_datetime
FROM outlook_messages
WHERE
    session_id = ?
    AND (? = '' OR from_email LIKE '%' || ? || '%')
    AND (? = '' OR to_email LIKE '%' || ? || '%')
    AND (? = '' OR subject LIKE '%' || ? || '%')
    AND (? = '' OR body_content LIKE '%' || ? || '%')
ORDER BY received_datetime DESC
LIMIT ?
`

type SearchOutlookMessagesParams struct {
	SessionID string         `json:"session_id"`
	Column2   interface{}    `json:"column_2"`
	Column3   sql.NullString `json:"column_3"`
	Column4   interface{}    `json:"column_4"`
	Column5   sql.NullString `json:"column_5"`
	Column6   interface{}    `json:"column_6"`
	Column7   sql.NullString `json:"column_7"`
	Column8   interface{}    `json:"column_8"`
	Column9   sql.NullString `json:"column_9"`
	Limit     int64          `json:"limit"`
}

type SearchOutlookMessagesRow struct {
	ID               string         `json:"id"`
	FromEmail        string         `json:"from_email"`
	ToEmail          string         `json:"to_email"`
	Subject          string         `json:"subject"`
	BodyContent      sql.NullString `json:"body_content"`
	BodyType         string         `json:"body_type"`
	IsRead           int64          `json:"is_read"`
	ReceivedDatetime string         `json:"received_datetime"`
}

func (q *Queries) SearchOutlookMessages(ctx context.Context, arg SearchOutlookMessagesParams) ([]SearchOutlookMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, searchOutlookMessages,
		arg.SessionID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchOutlookMessagesRow{}
	for rows.Next() {
		var i SearchOutlookMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.FromEmail,
			&i.ToEmail,
			&i.Subject,
			&i.BodyContent,
			&i.BodyType,
			&i.IsRead,
			&i.ReceivedDatetime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOutlookMessageReadStatus = `-- name: UpdateOutlookMessageReadStatus :exec
UPDATE outlook_messages
SET is_read = ?
WHERE id = ? AND session_id = ?
`

type UpdateOutlookMessageReadStatusParams struct {
	IsRead    int64  `json:"is_read"`
	ID        string `json:"id"`
	SessionID string `json:"session_id"`
}

func (q *Queries) UpdateOutlookMessageReadStatus(ctx context.Context, arg UpdateOutlookMessageReadStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateOutlookMessageReadStatus, arg.IsRead, arg.ID, arg.SessionID)
	return err
}
