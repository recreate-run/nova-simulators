// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: whatsapp.sql

package database

import (
	"context"
	"database/sql"
)

const createWhatsAppMessage = `-- name: CreateWhatsAppMessage :exec
INSERT INTO whatsapp_messages (id, phone_number_id, to_number, message_type, text_body, media_url, caption, template_name, language_code, session_id)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateWhatsAppMessageParams struct {
	ID            string         `json:"id"`
	PhoneNumberID string         `json:"phone_number_id"`
	ToNumber      string         `json:"to_number"`
	MessageType   string         `json:"message_type"`
	TextBody      sql.NullString `json:"text_body"`
	MediaUrl      sql.NullString `json:"media_url"`
	Caption       sql.NullString `json:"caption"`
	TemplateName  sql.NullString `json:"template_name"`
	LanguageCode  sql.NullString `json:"language_code"`
	SessionID     string         `json:"session_id"`
}

func (q *Queries) CreateWhatsAppMessage(ctx context.Context, arg CreateWhatsAppMessageParams) error {
	_, err := q.db.ExecContext(ctx, createWhatsAppMessage,
		arg.ID,
		arg.PhoneNumberID,
		arg.ToNumber,
		arg.MessageType,
		arg.TextBody,
		arg.MediaUrl,
		arg.Caption,
		arg.TemplateName,
		arg.LanguageCode,
		arg.SessionID,
	)
	return err
}

const deleteWhatsAppSessionData = `-- name: DeleteWhatsAppSessionData :exec
DELETE FROM whatsapp_messages WHERE session_id = ?
`

func (q *Queries) DeleteWhatsAppSessionData(ctx context.Context, sessionID string) error {
	_, err := q.db.ExecContext(ctx, deleteWhatsAppSessionData, sessionID)
	return err
}

const getWhatsAppMessageByID = `-- name: GetWhatsAppMessageByID :one
SELECT id, phone_number_id, to_number, message_type, text_body, media_url, caption, template_name, language_code, created_at
FROM whatsapp_messages
WHERE id = ? AND session_id = ?
`

type GetWhatsAppMessageByIDParams struct {
	ID        string `json:"id"`
	SessionID string `json:"session_id"`
}

type GetWhatsAppMessageByIDRow struct {
	ID            string         `json:"id"`
	PhoneNumberID string         `json:"phone_number_id"`
	ToNumber      string         `json:"to_number"`
	MessageType   string         `json:"message_type"`
	TextBody      sql.NullString `json:"text_body"`
	MediaUrl      sql.NullString `json:"media_url"`
	Caption       sql.NullString `json:"caption"`
	TemplateName  sql.NullString `json:"template_name"`
	LanguageCode  sql.NullString `json:"language_code"`
	CreatedAt     int64          `json:"created_at"`
}

func (q *Queries) GetWhatsAppMessageByID(ctx context.Context, arg GetWhatsAppMessageByIDParams) (GetWhatsAppMessageByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getWhatsAppMessageByID, arg.ID, arg.SessionID)
	var i GetWhatsAppMessageByIDRow
	err := row.Scan(
		&i.ID,
		&i.PhoneNumberID,
		&i.ToNumber,
		&i.MessageType,
		&i.TextBody,
		&i.MediaUrl,
		&i.Caption,
		&i.TemplateName,
		&i.LanguageCode,
		&i.CreatedAt,
	)
	return i, err
}

const listWhatsAppMessages = `-- name: ListWhatsAppMessages :many
SELECT id, phone_number_id, to_number, message_type, text_body, media_url, caption, template_name, language_code, created_at
FROM whatsapp_messages
WHERE session_id = ?
ORDER BY created_at DESC
LIMIT ?
`

type ListWhatsAppMessagesParams struct {
	SessionID string `json:"session_id"`
	Limit     int64  `json:"limit"`
}

type ListWhatsAppMessagesRow struct {
	ID            string         `json:"id"`
	PhoneNumberID string         `json:"phone_number_id"`
	ToNumber      string         `json:"to_number"`
	MessageType   string         `json:"message_type"`
	TextBody      sql.NullString `json:"text_body"`
	MediaUrl      sql.NullString `json:"media_url"`
	Caption       sql.NullString `json:"caption"`
	TemplateName  sql.NullString `json:"template_name"`
	LanguageCode  sql.NullString `json:"language_code"`
	CreatedAt     int64          `json:"created_at"`
}

func (q *Queries) ListWhatsAppMessages(ctx context.Context, arg ListWhatsAppMessagesParams) ([]ListWhatsAppMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, listWhatsAppMessages, arg.SessionID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListWhatsAppMessagesRow{}
	for rows.Next() {
		var i ListWhatsAppMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.PhoneNumberID,
			&i.ToNumber,
			&i.MessageType,
			&i.TextBody,
			&i.MediaUrl,
			&i.Caption,
			&i.TemplateName,
			&i.LanguageCode,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWhatsappMessagesBySession = `-- name: ListWhatsappMessagesBySession :many
SELECT id, phone_number_id, to_number, message_type, text_body, media_url, caption, template_name, language_code, created_at
FROM whatsapp_messages
WHERE session_id = ?
ORDER BY created_at DESC
`

type ListWhatsappMessagesBySessionRow struct {
	ID            string         `json:"id"`
	PhoneNumberID string         `json:"phone_number_id"`
	ToNumber      string         `json:"to_number"`
	MessageType   string         `json:"message_type"`
	TextBody      sql.NullString `json:"text_body"`
	MediaUrl      sql.NullString `json:"media_url"`
	Caption       sql.NullString `json:"caption"`
	TemplateName  sql.NullString `json:"template_name"`
	LanguageCode  sql.NullString `json:"language_code"`
	CreatedAt     int64          `json:"created_at"`
}

// UI data queries
func (q *Queries) ListWhatsappMessagesBySession(ctx context.Context, sessionID string) ([]ListWhatsappMessagesBySessionRow, error) {
	rows, err := q.db.QueryContext(ctx, listWhatsappMessagesBySession, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListWhatsappMessagesBySessionRow{}
	for rows.Next() {
		var i ListWhatsappMessagesBySessionRow
		if err := rows.Scan(
			&i.ID,
			&i.PhoneNumberID,
			&i.ToNumber,
			&i.MessageType,
			&i.TextBody,
			&i.MediaUrl,
			&i.Caption,
			&i.TemplateName,
			&i.LanguageCode,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
