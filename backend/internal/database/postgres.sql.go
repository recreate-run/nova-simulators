// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: postgres.sql

package database

import (
	"context"
	"database/sql"
)

const countPostgresRows = `-- name: CountPostgresRows :one
SELECT COUNT(*) as count
FROM postgres_rows
WHERE database_name = ? AND table_name = ? AND session_id = ?
`

type CountPostgresRowsParams struct {
	DatabaseName string `json:"database_name"`
	TableName    string `json:"table_name"`
	SessionID    string `json:"session_id"`
}

func (q *Queries) CountPostgresRows(ctx context.Context, arg CountPostgresRowsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPostgresRows, arg.DatabaseName, arg.TableName, arg.SessionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPostgresColumn = `-- name: CreatePostgresColumn :exec

INSERT INTO postgres_columns (database_name, table_name, column_name, data_type, is_nullable, column_default, ordinal_position, session_id)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreatePostgresColumnParams struct {
	DatabaseName    string         `json:"database_name"`
	TableName       string         `json:"table_name"`
	ColumnName      string         `json:"column_name"`
	DataType        string         `json:"data_type"`
	IsNullable      string         `json:"is_nullable"`
	ColumnDefault   sql.NullString `json:"column_default"`
	OrdinalPosition int64          `json:"ordinal_position"`
	SessionID       string         `json:"session_id"`
}

// Column queries
func (q *Queries) CreatePostgresColumn(ctx context.Context, arg CreatePostgresColumnParams) error {
	_, err := q.db.ExecContext(ctx, createPostgresColumn,
		arg.DatabaseName,
		arg.TableName,
		arg.ColumnName,
		arg.DataType,
		arg.IsNullable,
		arg.ColumnDefault,
		arg.OrdinalPosition,
		arg.SessionID,
	)
	return err
}

const createPostgresDatabase = `-- name: CreatePostgresDatabase :exec

INSERT INTO postgres_databases (name, session_id)
VALUES (?, ?)
`

type CreatePostgresDatabaseParams struct {
	Name      string `json:"name"`
	SessionID string `json:"session_id"`
}

// Database queries
func (q *Queries) CreatePostgresDatabase(ctx context.Context, arg CreatePostgresDatabaseParams) error {
	_, err := q.db.ExecContext(ctx, createPostgresDatabase, arg.Name, arg.SessionID)
	return err
}

const createPostgresTable = `-- name: CreatePostgresTable :exec

INSERT INTO postgres_tables (database_name, table_name, session_id)
VALUES (?, ?, ?)
`

type CreatePostgresTableParams struct {
	DatabaseName string `json:"database_name"`
	TableName    string `json:"table_name"`
	SessionID    string `json:"session_id"`
}

// Table queries
func (q *Queries) CreatePostgresTable(ctx context.Context, arg CreatePostgresTableParams) error {
	_, err := q.db.ExecContext(ctx, createPostgresTable, arg.DatabaseName, arg.TableName, arg.SessionID)
	return err
}

const deletePostgresColumns = `-- name: DeletePostgresColumns :exec
DELETE FROM postgres_columns
WHERE database_name = ? AND table_name = ? AND session_id = ?
`

type DeletePostgresColumnsParams struct {
	DatabaseName string `json:"database_name"`
	TableName    string `json:"table_name"`
	SessionID    string `json:"session_id"`
}

func (q *Queries) DeletePostgresColumns(ctx context.Context, arg DeletePostgresColumnsParams) error {
	_, err := q.db.ExecContext(ctx, deletePostgresColumns, arg.DatabaseName, arg.TableName, arg.SessionID)
	return err
}

const deletePostgresRow = `-- name: DeletePostgresRow :exec
DELETE FROM postgres_rows
WHERE id = ? AND session_id = ?
`

type DeletePostgresRowParams struct {
	ID        int64  `json:"id"`
	SessionID string `json:"session_id"`
}

func (q *Queries) DeletePostgresRow(ctx context.Context, arg DeletePostgresRowParams) error {
	_, err := q.db.ExecContext(ctx, deletePostgresRow, arg.ID, arg.SessionID)
	return err
}

const deletePostgresRowsByTable = `-- name: DeletePostgresRowsByTable :exec
DELETE FROM postgres_rows
WHERE database_name = ? AND table_name = ? AND session_id = ?
`

type DeletePostgresRowsByTableParams struct {
	DatabaseName string `json:"database_name"`
	TableName    string `json:"table_name"`
	SessionID    string `json:"session_id"`
}

func (q *Queries) DeletePostgresRowsByTable(ctx context.Context, arg DeletePostgresRowsByTableParams) error {
	_, err := q.db.ExecContext(ctx, deletePostgresRowsByTable, arg.DatabaseName, arg.TableName, arg.SessionID)
	return err
}

const deletePostgresSessionData = `-- name: DeletePostgresSessionData :exec

DELETE FROM postgres_databases WHERE session_id = ?
`

// Cleanup queries
func (q *Queries) DeletePostgresSessionData(ctx context.Context, sessionID string) error {
	_, err := q.db.ExecContext(ctx, deletePostgresSessionData, sessionID)
	return err
}

const deletePostgresTable = `-- name: DeletePostgresTable :exec
DELETE FROM postgres_tables
WHERE database_name = ? AND table_name = ? AND session_id = ?
`

type DeletePostgresTableParams struct {
	DatabaseName string `json:"database_name"`
	TableName    string `json:"table_name"`
	SessionID    string `json:"session_id"`
}

func (q *Queries) DeletePostgresTable(ctx context.Context, arg DeletePostgresTableParams) error {
	_, err := q.db.ExecContext(ctx, deletePostgresTable, arg.DatabaseName, arg.TableName, arg.SessionID)
	return err
}

const getPostgresDatabase = `-- name: GetPostgresDatabase :one
SELECT id, name, created_at
FROM postgres_databases
WHERE name = ? AND session_id = ?
`

type GetPostgresDatabaseParams struct {
	Name      string `json:"name"`
	SessionID string `json:"session_id"`
}

type GetPostgresDatabaseRow struct {
	ID        int64  `json:"id"`
	Name      string `json:"name"`
	CreatedAt int64  `json:"created_at"`
}

func (q *Queries) GetPostgresDatabase(ctx context.Context, arg GetPostgresDatabaseParams) (GetPostgresDatabaseRow, error) {
	row := q.db.QueryRowContext(ctx, getPostgresDatabase, arg.Name, arg.SessionID)
	var i GetPostgresDatabaseRow
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return i, err
}

const getPostgresTable = `-- name: GetPostgresTable :one
SELECT id, database_name, table_name, created_at
FROM postgres_tables
WHERE database_name = ? AND table_name = ? AND session_id = ?
`

type GetPostgresTableParams struct {
	DatabaseName string `json:"database_name"`
	TableName    string `json:"table_name"`
	SessionID    string `json:"session_id"`
}

type GetPostgresTableRow struct {
	ID           int64  `json:"id"`
	DatabaseName string `json:"database_name"`
	TableName    string `json:"table_name"`
	CreatedAt    int64  `json:"created_at"`
}

func (q *Queries) GetPostgresTable(ctx context.Context, arg GetPostgresTableParams) (GetPostgresTableRow, error) {
	row := q.db.QueryRowContext(ctx, getPostgresTable, arg.DatabaseName, arg.TableName, arg.SessionID)
	var i GetPostgresTableRow
	err := row.Scan(
		&i.ID,
		&i.DatabaseName,
		&i.TableName,
		&i.CreatedAt,
	)
	return i, err
}

const insertPostgresRow = `-- name: InsertPostgresRow :one

INSERT INTO postgres_rows (database_name, table_name, row_data, session_id)
VALUES (?, ?, ?, ?)
RETURNING id, database_name, table_name, row_data, created_at, updated_at
`

type InsertPostgresRowParams struct {
	DatabaseName string `json:"database_name"`
	TableName    string `json:"table_name"`
	RowData      string `json:"row_data"`
	SessionID    string `json:"session_id"`
}

type InsertPostgresRowRow struct {
	ID           int64  `json:"id"`
	DatabaseName string `json:"database_name"`
	TableName    string `json:"table_name"`
	RowData      string `json:"row_data"`
	CreatedAt    int64  `json:"created_at"`
	UpdatedAt    int64  `json:"updated_at"`
}

// Row queries
func (q *Queries) InsertPostgresRow(ctx context.Context, arg InsertPostgresRowParams) (InsertPostgresRowRow, error) {
	row := q.db.QueryRowContext(ctx, insertPostgresRow,
		arg.DatabaseName,
		arg.TableName,
		arg.RowData,
		arg.SessionID,
	)
	var i InsertPostgresRowRow
	err := row.Scan(
		&i.ID,
		&i.DatabaseName,
		&i.TableName,
		&i.RowData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPostgresColumns = `-- name: ListPostgresColumns :many
SELECT id, database_name, table_name, column_name, data_type, is_nullable, column_default, ordinal_position
FROM postgres_columns
WHERE database_name = ? AND table_name = ? AND session_id = ?
ORDER BY ordinal_position ASC
`

type ListPostgresColumnsParams struct {
	DatabaseName string `json:"database_name"`
	TableName    string `json:"table_name"`
	SessionID    string `json:"session_id"`
}

type ListPostgresColumnsRow struct {
	ID              int64          `json:"id"`
	DatabaseName    string         `json:"database_name"`
	TableName       string         `json:"table_name"`
	ColumnName      string         `json:"column_name"`
	DataType        string         `json:"data_type"`
	IsNullable      string         `json:"is_nullable"`
	ColumnDefault   sql.NullString `json:"column_default"`
	OrdinalPosition int64          `json:"ordinal_position"`
}

func (q *Queries) ListPostgresColumns(ctx context.Context, arg ListPostgresColumnsParams) ([]ListPostgresColumnsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPostgresColumns, arg.DatabaseName, arg.TableName, arg.SessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPostgresColumnsRow{}
	for rows.Next() {
		var i ListPostgresColumnsRow
		if err := rows.Scan(
			&i.ID,
			&i.DatabaseName,
			&i.TableName,
			&i.ColumnName,
			&i.DataType,
			&i.IsNullable,
			&i.ColumnDefault,
			&i.OrdinalPosition,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostgresDatabases = `-- name: ListPostgresDatabases :many
SELECT id, name, created_at
FROM postgres_databases
WHERE session_id = ?
ORDER BY created_at DESC
`

type ListPostgresDatabasesRow struct {
	ID        int64  `json:"id"`
	Name      string `json:"name"`
	CreatedAt int64  `json:"created_at"`
}

func (q *Queries) ListPostgresDatabases(ctx context.Context, sessionID string) ([]ListPostgresDatabasesRow, error) {
	rows, err := q.db.QueryContext(ctx, listPostgresDatabases, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPostgresDatabasesRow{}
	for rows.Next() {
		var i ListPostgresDatabasesRow
		if err := rows.Scan(&i.ID, &i.Name, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostgresQueryLog = `-- name: ListPostgresQueryLog :many
SELECT id, database_name, query_text, query_type, rows_affected, executed_at
FROM postgres_query_log
WHERE session_id = ? AND database_name = ?
ORDER BY executed_at DESC
LIMIT ?
`

type ListPostgresQueryLogParams struct {
	SessionID    string `json:"session_id"`
	DatabaseName string `json:"database_name"`
	Limit        int64  `json:"limit"`
}

type ListPostgresQueryLogRow struct {
	ID           int64         `json:"id"`
	DatabaseName string        `json:"database_name"`
	QueryText    string        `json:"query_text"`
	QueryType    string        `json:"query_type"`
	RowsAffected sql.NullInt64 `json:"rows_affected"`
	ExecutedAt   int64         `json:"executed_at"`
}

func (q *Queries) ListPostgresQueryLog(ctx context.Context, arg ListPostgresQueryLogParams) ([]ListPostgresQueryLogRow, error) {
	rows, err := q.db.QueryContext(ctx, listPostgresQueryLog, arg.SessionID, arg.DatabaseName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPostgresQueryLogRow{}
	for rows.Next() {
		var i ListPostgresQueryLogRow
		if err := rows.Scan(
			&i.ID,
			&i.DatabaseName,
			&i.QueryText,
			&i.QueryType,
			&i.RowsAffected,
			&i.ExecutedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostgresRows = `-- name: ListPostgresRows :many
SELECT id, database_name, table_name, row_data, created_at, updated_at
FROM postgres_rows
WHERE database_name = ? AND table_name = ? AND session_id = ?
ORDER BY id ASC
`

type ListPostgresRowsParams struct {
	DatabaseName string `json:"database_name"`
	TableName    string `json:"table_name"`
	SessionID    string `json:"session_id"`
}

type ListPostgresRowsRow struct {
	ID           int64  `json:"id"`
	DatabaseName string `json:"database_name"`
	TableName    string `json:"table_name"`
	RowData      string `json:"row_data"`
	CreatedAt    int64  `json:"created_at"`
	UpdatedAt    int64  `json:"updated_at"`
}

func (q *Queries) ListPostgresRows(ctx context.Context, arg ListPostgresRowsParams) ([]ListPostgresRowsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPostgresRows, arg.DatabaseName, arg.TableName, arg.SessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPostgresRowsRow{}
	for rows.Next() {
		var i ListPostgresRowsRow
		if err := rows.Scan(
			&i.ID,
			&i.DatabaseName,
			&i.TableName,
			&i.RowData,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostgresTables = `-- name: ListPostgresTables :many
SELECT id, database_name, table_name, created_at
FROM postgres_tables
WHERE database_name = ? AND session_id = ?
ORDER BY table_name ASC
`

type ListPostgresTablesParams struct {
	DatabaseName string `json:"database_name"`
	SessionID    string `json:"session_id"`
}

type ListPostgresTablesRow struct {
	ID           int64  `json:"id"`
	DatabaseName string `json:"database_name"`
	TableName    string `json:"table_name"`
	CreatedAt    int64  `json:"created_at"`
}

func (q *Queries) ListPostgresTables(ctx context.Context, arg ListPostgresTablesParams) ([]ListPostgresTablesRow, error) {
	rows, err := q.db.QueryContext(ctx, listPostgresTables, arg.DatabaseName, arg.SessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPostgresTablesRow{}
	for rows.Next() {
		var i ListPostgresTablesRow
		if err := rows.Scan(
			&i.ID,
			&i.DatabaseName,
			&i.TableName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logPostgresQuery = `-- name: LogPostgresQuery :exec

INSERT INTO postgres_query_log (database_name, query_text, query_type, rows_affected, session_id)
VALUES (?, ?, ?, ?, ?)
`

type LogPostgresQueryParams struct {
	DatabaseName string        `json:"database_name"`
	QueryText    string        `json:"query_text"`
	QueryType    string        `json:"query_type"`
	RowsAffected sql.NullInt64 `json:"rows_affected"`
	SessionID    string        `json:"session_id"`
}

// Query log queries
func (q *Queries) LogPostgresQuery(ctx context.Context, arg LogPostgresQueryParams) error {
	_, err := q.db.ExecContext(ctx, logPostgresQuery,
		arg.DatabaseName,
		arg.QueryText,
		arg.QueryType,
		arg.RowsAffected,
		arg.SessionID,
	)
	return err
}

const updatePostgresRow = `-- name: UpdatePostgresRow :exec
UPDATE postgres_rows
SET row_data = ?, updated_at = unixepoch()
WHERE id = ? AND session_id = ?
`

type UpdatePostgresRowParams struct {
	RowData   string `json:"row_data"`
	ID        int64  `json:"id"`
	SessionID string `json:"session_id"`
}

func (q *Queries) UpdatePostgresRow(ctx context.Context, arg UpdatePostgresRowParams) error {
	_, err := q.db.ExecContext(ctx, updatePostgresRow, arg.RowData, arg.ID, arg.SessionID)
	return err
}
