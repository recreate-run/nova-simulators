// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: session_config.sql

package database

import (
	"context"
)

const deleteSessionConfig = `-- name: DeleteSessionConfig :exec
DELETE FROM session_configs
WHERE session_id = ? AND simulator_name = ?
`

type DeleteSessionConfigParams struct {
	SessionID     string `json:"session_id"`
	SimulatorName string `json:"simulator_name"`
}

func (q *Queries) DeleteSessionConfig(ctx context.Context, arg DeleteSessionConfigParams) error {
	_, err := q.db.ExecContext(ctx, deleteSessionConfig, arg.SessionID, arg.SimulatorName)
	return err
}

const getSessionConfig = `-- name: GetSessionConfig :one
SELECT timeout_min_ms, timeout_max_ms, rate_limit_per_minute, rate_limit_per_day
FROM session_configs
WHERE session_id = ? AND simulator_name = ?
`

type GetSessionConfigParams struct {
	SessionID     string `json:"session_id"`
	SimulatorName string `json:"simulator_name"`
}

type GetSessionConfigRow struct {
	TimeoutMinMs       int64 `json:"timeout_min_ms"`
	TimeoutMaxMs       int64 `json:"timeout_max_ms"`
	RateLimitPerMinute int64 `json:"rate_limit_per_minute"`
	RateLimitPerDay    int64 `json:"rate_limit_per_day"`
}

func (q *Queries) GetSessionConfig(ctx context.Context, arg GetSessionConfigParams) (GetSessionConfigRow, error) {
	row := q.db.QueryRowContext(ctx, getSessionConfig, arg.SessionID, arg.SimulatorName)
	var i GetSessionConfigRow
	err := row.Scan(
		&i.TimeoutMinMs,
		&i.TimeoutMaxMs,
		&i.RateLimitPerMinute,
		&i.RateLimitPerDay,
	)
	return i, err
}

const listSessionConfigs = `-- name: ListSessionConfigs :many
SELECT session_id, simulator_name, timeout_min_ms, timeout_max_ms, rate_limit_per_minute, rate_limit_per_day, created_at, updated_at
FROM session_configs
WHERE session_id = ?
ORDER BY simulator_name
`

func (q *Queries) ListSessionConfigs(ctx context.Context, sessionID string) ([]SessionConfig, error) {
	rows, err := q.db.QueryContext(ctx, listSessionConfigs, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SessionConfig{}
	for rows.Next() {
		var i SessionConfig
		if err := rows.Scan(
			&i.SessionID,
			&i.SimulatorName,
			&i.TimeoutMinMs,
			&i.TimeoutMaxMs,
			&i.RateLimitPerMinute,
			&i.RateLimitPerDay,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertSessionConfig = `-- name: UpsertSessionConfig :exec
INSERT INTO session_configs (session_id, simulator_name, timeout_min_ms, timeout_max_ms, rate_limit_per_minute, rate_limit_per_day, updated_at)
VALUES (?, ?, ?, ?, ?, ?, unixepoch())
ON CONFLICT(session_id, simulator_name) DO UPDATE SET
    timeout_min_ms = excluded.timeout_min_ms,
    timeout_max_ms = excluded.timeout_max_ms,
    rate_limit_per_minute = excluded.rate_limit_per_minute,
    rate_limit_per_day = excluded.rate_limit_per_day,
    updated_at = unixepoch()
`

type UpsertSessionConfigParams struct {
	SessionID          string `json:"session_id"`
	SimulatorName      string `json:"simulator_name"`
	TimeoutMinMs       int64  `json:"timeout_min_ms"`
	TimeoutMaxMs       int64  `json:"timeout_max_ms"`
	RateLimitPerMinute int64  `json:"rate_limit_per_minute"`
	RateLimitPerDay    int64  `json:"rate_limit_per_day"`
}

func (q *Queries) UpsertSessionConfig(ctx context.Context, arg UpsertSessionConfigParams) error {
	_, err := q.db.ExecContext(ctx, upsertSessionConfig,
		arg.SessionID,
		arg.SimulatorName,
		arg.TimeoutMinMs,
		arg.TimeoutMaxMs,
		arg.RateLimitPerMinute,
		arg.RateLimitPerDay,
	)
	return err
}
